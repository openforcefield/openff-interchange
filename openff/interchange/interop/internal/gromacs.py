"""Interfaces with GROMACS."""
import math
import warnings
from collections import defaultdict
from pathlib import Path
from typing import IO, TYPE_CHECKING, Callable, Dict, List, Optional, Set, Tuple, Union

import numpy as np
from openff.toolkit.topology import Molecule, Topology
from openff.toolkit.topology._mm_molecule import _SimpleMolecule
from openff.units import unit

from openff.interchange.components.base import (
    BaseAngleHandler,
    BaseBondHandler,
    BaseElectrostaticsHandler,
    BaseImproperTorsionHandler,
    BaseProperTorsionHandler,
    BasevdWHandler,
)
from openff.interchange.components.potentials import Potential
from openff.interchange.components.toolkit import _get_14_pairs
from openff.interchange.constants import _PME, kj_mol
from openff.interchange.exceptions import MissingPositionsError, UnsupportedExportError
from openff.interchange.interop._virtual_sites import (
    _get_virtual_site_positions,
    _virtual_site_parent_molecule_mapping,
)
from openff.interchange.models import PotentialKey, TopologyKey, VirtualSiteKey

if TYPE_CHECKING:
    from openff.units.unit import Quantity

    from openff.interchange import Interchange
    from openff.interchange.components.potentials import PotentialHandler


def to_gro(openff_sys: "Interchange", file_path: Union[Path, str], decimal: int = 3):
    """
    Write a GROMACS coordinate (.gro) file.

    See https://manual.gromacs.org/documentation/current/reference-manual/file-formats.html#gro
    for more details, including the recommended C-style one-liners

    This code is partially copied from InterMol, see
    https://github.com/shirtsgroup/InterMol/tree/v0.1/intermol/gromacs

    """
    if isinstance(file_path, str):
        path = Path(file_path)
    if isinstance(file_path, Path):
        path = file_path

    if openff_sys.positions is None:
        raise MissingPositionsError(
            "Positions are required to write a `.gro` file but found None.",
        )
    elif np.allclose(openff_sys.positions, 0):
        warnings.warn(
            "Positions seem to all be zero. Result coordinate file may be non-physical.",
            UserWarning,
        )
    # Explicitly round here to avoid ambiguous things in string formatting
    rounded_positions = np.round(openff_sys.positions, decimal)
    rounded_positions = rounded_positions.m_as(unit.nanometer)

    n = decimal

    n_particles = openff_sys.positions.shape[0]

    if openff_sys.topology.n_atoms != n_particles:
        raise MissingPositionsError(
            "Found a mismatch in the number of atoms in the provided topology and positions "
            f"matrix. Detected {openff_sys.topology.n_atoms} atoms in the topology but found "
            f"{n_particles} positions in `.positions` attribute.",
        )

    virtual_site_map = _build_virtual_site_map(openff_sys)
    n_particles += len(virtual_site_map)

    # this must be Dict[int, List[VirtualSiteKey]] because one molecule can contain multiple virtual sites
    molecule_virtual_site_map = defaultdict(list)

    if len(virtual_site_map) > 0:
        virtual_site_molecule_map = _virtual_site_parent_molecule_mapping(openff_sys)

        for virtual_site, molecule_index in virtual_site_molecule_map.items():
            molecule_virtual_site_map[molecule_index].append(virtual_site)

    with open(path, "w") as gro:
        gro.write("Generated by Interchange\n")
        gro.write(f"{n_particles}\n")

        n_virtual_sites = 0

        for molecule_index, molecule in enumerate(openff_sys.topology.molecules):
            for atom in molecule.atoms:

                residue_index, residue_name = _get_residue_info_from_atom(atom)

                topology_index = openff_sys.topology.atom_index(atom)

                atom_name = atom.name if atom.name else atom.symbol

                gmx_atom_index = (topology_index + 1 + n_virtual_sites) % 100000

                gro.write(
                    f"%5d%-5s%5s%5d%{n+5}.{n}f%{n+5}.{n}f%{n+5}.{n}f\n"
                    % (
                        residue_index,
                        residue_name,
                        atom_name,
                        gmx_atom_index,
                        rounded_positions[topology_index, 0],
                        rounded_positions[topology_index, 1],
                        rounded_positions[topology_index, 2],
                    ),
                )

            try:
                virtual_site_keys: List[VirtualSiteKey] = molecule_virtual_site_map[
                    molecule_index
                ]
            except KeyError:
                # This molecule is not in the mapping between molecules and virtual site keys
                continue

            # Infer residue information from the the last atom we happened to be iterating through in this molecule
            # This will need to be updated to actually point to the right atom, since here we assume the molecule
            # containing virtual sites includes only one residue
            residue_index, residue_name = _get_residue_info_from_atom(atom)

            # TODO: What should virtual sites be named? Does it matter?
            atom_name = "VS"

            last_atom_index = topology_index

            for virtual_site_key in virtual_site_keys:
                r_virtual_site = _get_virtual_site_positions(
                    virtual_site_key,
                    openff_sys,
                )
                r_virtual_site_nm = r_virtual_site.m_as(unit.nanometer)

                gmx_atom_index = (last_atom_index + 1 + n_virtual_sites) % 100000

                gro.write(
                    f"%5d%-5s%5s%5d%{n+5}.{n}f%{n+5}.{n}f%{n+5}.{n}f\n"
                    % (
                        residue_index,
                        residue_name,
                        atom_name,
                        gmx_atom_index,
                        r_virtual_site_nm[0],
                        r_virtual_site_nm[1],
                        r_virtual_site_nm[2],
                    ),
                )

                n_virtual_sites += 1

        if openff_sys.box is None:
            warnings.warn(
                "WARNING: System defined with no box vectors, which GROMACS does not offically "
                "support in versions 2020 or newer (see "
                "https://gitlab.com/gromacs/gromacs/-/issues/3526). Setting box vectors to a 5 "
                " nm cube.",
            )
            box = 5 * np.eye(3)
        else:
            box = openff_sys.box.m_as(unit.nanometer)

        # Check for rectangular
        if (box == np.diag(np.diagonal(box))).all():
            for i in range(3):
                gro.write(f"{box[i, i]:11.7f}")
        else:
            for i in range(3):
                gro.write(f"{box[i, i]:11.7f}")
            for i in range(3):
                for j in range(3):
                    if i != j:
                        gro.write(f"{box[i, j]:11.7f}")

        gro.write("\n")


def _read_coordinates(file_path: Union[Path, str]) -> np.ndarray:
    def _infer_coord_precision(file_path: Union[Path, str]) -> int:
        """
        Infer decimal precision of coordinates by parsing periods in atoms lines.
        """
        with open(file_path) as file_in:
            file_in.readline()
            file_in.readline()
            atom_line = file_in.readline()
            period_indices = [i for i, x in enumerate(atom_line) if x == "."]
            spacing_between_periods = period_indices[-1] - period_indices[-2]
            precision = spacing_between_periods - 5
            return precision

    precision = _infer_coord_precision(file_path)
    coordinate_width = precision + 5
    # Column numbers in file separating x, y, z coords of each atom.
    # Default (3 decimals of precision -> 8 columns) are 20, 28, 36, 44
    coordinate_columns = [
        20,
        20 + coordinate_width,
        20 + 2 * coordinate_width,
        20 + 3 * coordinate_width,
    ]

    with open(file_path) as gro_file:
        # Throw away comment / name line
        gro_file.readline()
        n_atoms = int(gro_file.readline())

        unitless_coordinates = np.zeros((n_atoms, 3))
        for coordinate_index in range(n_atoms):
            line = gro_file.readline()
            _ = int(line[:5])  # residue_index
            _ = line[5:10]  # residue_name
            _ = line[10:15]  # atom_name
            _ = int(line[15:20])  # atom_index
            x = float(line[coordinate_columns[0] : coordinate_columns[1]])
            y = float(line[coordinate_columns[1] : coordinate_columns[2]])
            z = float(line[coordinate_columns[2] : coordinate_columns[3]])
            unitless_coordinates[coordinate_index] = np.array([x, y, z])

        coordinates = unitless_coordinates * unit.nanometer

    return coordinates


def _read_box(file_path: Union[Path, str]) -> np.ndarray:

    with open(file_path) as gro_file:
        # Throw away comment / name line
        gro_file.readline()
        n_atoms = int(gro_file.readline())

        box_line = gro_file.readlines()[n_atoms]

    parsed_box = [float(val) for val in box_line.split()]

    if len(parsed_box) == 3:
        box = parsed_box * np.eye(3) * unit.nanometer

    return box


def from_gro(file_path: Union[Path, str]) -> "Interchange":
    """Read coordinates and box information from a GROMACS GRO (.gro) file."""
    if isinstance(file_path, str):
        path = Path(file_path)
    if isinstance(file_path, Path):
        path = file_path

    coordinates = _read_coordinates(path)

    box = _read_box(path)

    from openff.interchange import Interchange

    interchange = Interchange()
    interchange.box = box
    interchange.positions = coordinates

    return interchange


def to_top(openff_sys: "Interchange", file_path: Union[Path, str]):
    """
    Write a GROMACS topology (.top) file.

    See https://manual.gromacs.org/documentation/current/reference-manual/file-formats.html#top
    for more details.

    This code is partially copied from InterMol, see
    https://github.com/shirtsgroup/InterMol/tree/v0.1/intermol/gromacs

    """
    if "VirtualSites" in openff_sys.handlers:
        if len(openff_sys["VirtualSites"].slot_map) > 0:
            warnings.warn(
                "Exporting virtual sites to GROMACS is EXPERIMENTAL and not yet thoroughly validated.",
            )

    if isinstance(file_path, str):
        path = Path(file_path)
    if isinstance(file_path, Path):
        path = file_path

    if openff_sys.box is None:
        if openff_sys["Electrostatics"].periodic_potential != _PME:
            raise UnsupportedExportError(
                f'Electrostatics method PME (`"{_PME}"`) is not valid for a non-periodic system. ',
            )

    # For performance, immediately convert everything into GROMACS units.  This
    # introduces an overhead but should pay off by allowing the blind use of
    # `Quantity.magnitdue` without the default unit-checking work.

    if "vdW" in openff_sys.handlers:
        for potential in openff_sys["vdW"].potentials.values():
            potential.parameters["sigma"].ito(unit.nanometer)
            potential.parameters["epsilon"].ito(kj_mol)

    if "Bonds" in openff_sys.handlers:
        for potential in openff_sys["Bonds"].potentials.values():
            potential.parameters["k"].ito(kj_mol / unit.nanometer**2)
            potential.parameters["length"].ito(unit.nanometer)

    if "Angles" in openff_sys.handlers:
        for potential in openff_sys["Angles"].potentials.values():
            potential.parameters["k"].ito(kj_mol / unit.radian * 2)
            potential.parameters["angle"].ito(unit.degree)

    if "ProperTorsions" in openff_sys.handlers:
        for potential in openff_sys["ProperTorsions"].potentials.values():
            potential.parameters["k"].ito(kj_mol)
            potential.parameters["phase"].ito(unit.degree)

    if "ImproperTorsions" in openff_sys.handlers:
        for potential in openff_sys["ImproperTorsions"].potentials.values():
            potential.parameters["k"].ito(kj_mol)
            potential.parameters["phase"].ito(unit.degree)

    with open(path, "w") as top_file:
        top_file.write("; Generated by Interchange\n")
        _write_top_defaults(openff_sys, top_file)
        typemap = _build_typemap(openff_sys)
        virtual_site_map = _build_virtual_site_map(openff_sys)
        _write_atomtypes(openff_sys, top_file, typemap, virtual_site_map)
        # TODO: Write [ nonbond_params ] section

        try:
            lj_parameters = openff_sys["vdW"].get_system_parameters()
        except LookupError:
            lj_parameters = None

        unique_molecule_map: Dict[
            int,
            List,
        ] = openff_sys.topology.identical_molecule_groups

        for (
            unique_molecule_index,
            duplicate_molecule_data,
        ) in unique_molecule_map.items():
            unique_molecule = openff_sys.topology.molecule(unique_molecule_index)

            if unique_molecule.name == "":
                unique_molecule.name = "x" + str(unique_molecule_index)

            for row in duplicate_molecule_data:
                (duplciate_molecule_index, _) = row

                openff_sys.topology.molecule(
                    duplciate_molecule_index,
                ).name = unique_molecule.name

            _write_moleculetype(top_file, unique_molecule.name)
            _write_atoms(
                top_file,
                openff_sys,
                unique_molecule,
                typemap,
                virtual_site_map,
                _cached_parameters=lj_parameters,
            )
            _write_valence(top_file, openff_sys, unique_molecule)
            _write_virtual_sites(
                top_file,
                openff_sys,
                unique_molecule,
                virtual_site_map,
            )

        _write_system(top_file, openff_sys, unique_molecule_map)


def _write_top_defaults(openff_sys: "Interchange", top_file: IO):
    """Write [ defaults ] section."""
    top_file.write("[ defaults ]\n")
    top_file.write("; nbfunc\tcomb-rule\tgen-pairs\tfudgeLJ\tfudgeQQ\n")

    if "vdW" in openff_sys.handlers:
        nbfunc = 1
        scale_lj = openff_sys["vdW"].scale_14
        gen_pairs = "no"
        handler_key = "vdW"
    elif "Buckingham-6" in openff_sys.handlers:
        nbfunc = 2
        gen_pairs = "no"
        scale_lj = openff_sys["Buckingham-6"].scale_14  # type: ignore
        handler_key = "Buckingham-6"
    else:
        raise UnsupportedExportError(
            "Could not find a handler for short-ranged vdW interactions that is compatible "
            "with GROMACS. Looked for handlers named `vdW` and `Buckingham-6`.",
        )

    mixing_rule = openff_sys[handler_key].mixing_rule.lower()  # type: ignore
    if mixing_rule == "lorentz-berthelot":
        comb_rule = 2
    elif mixing_rule == "geometric":
        comb_rule = 3
    elif mixing_rule == "buckingham" and handler_key == "Buckingham-6":
        # TODO: Not clear what the compatibility is here. `comb-rule` only applies to LJ terms.
        #  The documentation lists the combination rule for Buckingham potentials, but it does not
        #  seem like GROMACS will do this automatically, and needs to be implemented manully via
        #  [ nonbond_params ].
        # https://manual.gromacs.org/current/reference-manual/topologies/parameter-files.html#non-bonded-parameters
        # https://gromacs.bioexcel.eu/t/how-to-use-buckingham-function/1181/4
        comb_rule = 2
    else:
        raise UnsupportedExportError(
            f"Mixing rule `{mixing_rule} not compatible with GROMACS and/or not supported "
            "by current exporter. Supported values are `lorentz-berthelot` and `geometric`.",
        )

    top_file.write(
        "{:6d}\t{:6d}\t{:6s} {:8.6f} {:8.6f}\n\n".format(
            nbfunc,
            comb_rule,
            gen_pairs,
            scale_lj,
            openff_sys["Electrostatics"].scale_14,
        ),
    )


def _build_typemap(openff_sys: "Interchange") -> Dict[int, str]:
    typemap = dict()
    elements: Dict[str, int] = dict()

    # TODO: Think about how this logic relates to atom name/type clashes
    for atom_index, atom in enumerate(openff_sys.topology.atoms):
        element_symbol = atom.symbol
        # TODO: Use this key to condense, see parmed.openmm._process_nobonded
        # parameters = _get_lj_parameters([*parameters.values()])
        # key = tuple([*parameters.values()])

        if element_symbol not in elements.keys():
            elements[element_symbol] = 1
        else:
            elements[element_symbol] += 1

        atom_type = f"{element_symbol}{elements[element_symbol]}"
        typemap[atom_index] = atom_type

    return typemap


def _build_virtual_site_map(interchange: "Interchange") -> Dict[VirtualSiteKey, int]:
    """
    Construct a mapping between the VirtualSiteKey objects found in a SMIRNOFFVirtualSiteHandler and particle indices.
    """
    virtual_site_topology_index_map: Dict[VirtualSiteKey, int] = dict()

    if "VirtualSites" not in interchange.handlers:
        return virtual_site_topology_index_map

    n_atoms = interchange.topology.n_atoms

    for index, virtual_site_key in enumerate(
        interchange["VirtualSites"].slot_map.keys(),
    ):
        virtual_site_topology_index_map[virtual_site_key] = n_atoms + 1 + index

    return virtual_site_topology_index_map


def _write_atomtypes(
    openff_sys: "Interchange",
    top_file: IO,
    typemap: Dict,
    virtual_site_map: Dict,
):
    """Write [ atomtypes ] section."""
    if "vdW" in openff_sys.handlers:
        if "Buckingham-6" in openff_sys.handlers:
            raise UnsupportedExportError(
                "Cannot mix 12-6 and Buckingham potentials in GROMACS",
            )
        else:
            _write_atomtypes_lj(openff_sys, top_file, typemap, virtual_site_map)
    else:
        if "Buckingham-6" in openff_sys.handlers:
            _write_atomtypes_buck(openff_sys, top_file, typemap)
        else:
            raise UnsupportedExportError("No vdW interactions found")

    top_file.write("\n")


def _write_atomtypes_lj(
    openff_sys: "Interchange",
    top_file: IO,
    typemap: Dict,
    virtual_site_map: Dict,
):
    """Write the [ atomtypes ] section when all atoms use the LJ potential."""
    top_file.write("[ atomtypes ]\n")
    top_file.write(";type, bondingtype, mass, charge, ptype, sigma, epsilon\n")

    lj_parameters = openff_sys["vdW"].get_system_parameters()

    for atom_idx, atom_type in typemap.items():
        atom = openff_sys.topology.atom(atom_idx)
        mass = atom.mass.m
        atomic_number = atom.atomic_number
        sigma, epsilon = lj_parameters[atom_idx]
        # TODO: Sometimes a "bondingtype" can sneak in to as the second column. This
        #       seems to be used commonly in how OPLS groups atom types for valence
        #       terms, and InterMol attempts to parse it as such, but the GROMACS
        #       documentation makes no mention of this behavior.
        top_file.write(
            "{:<11s} {:6d} {:.16g} {:.16f} {:5s} {:.16g} {:.16g}\n".format(
                atom_type,
                atomic_number,
                mass,
                0.0,  # charge, overriden later in [ atoms ]
                "A",  # ptype
                sigma,
                epsilon,
            ),
        )

    for virtual_site_key in virtual_site_map:
        # TODO: This can produce some silly-looking output because it does not attempt to condense virtual sites
        #       from different molecules with the same parameters. Should probably de-deuplicate across moleculces
        atom_type = "VS"
        atomic_number = 0
        mass = 0.0

        vdw_handler = openff_sys["vdW"]
        pot_key = vdw_handler.slot_map[virtual_site_key]
        parameters = vdw_handler.potentials[pot_key].parameters
        sigma = parameters["sigma"].m
        epsilon = parameters["epsilon"].m

        top_file.write(
            "{:<11s} {:6d} {:.16g} {:.16g} {:5s} {:.16g} {:.16g}\n".format(
                atom_type,
                # "XX",  # atom "bonding type", i.e. bond class
                atomic_number,
                mass,
                0.0,  # charge, overriden later in [ atoms ]
                "A",  # ptype
                sigma,
                epsilon,
            ),
        )


def _write_atomtypes_buck(openff_sys: "Interchange", top_file: IO, typemap: Dict):
    """Write the [ atomtypes ] section when all atoms use the Buckingham-6 potential."""
    top_file.write("[ atomtypes ]\n")
    top_file.write(
        ";type, bondingtype, atomic_number, mass, charge, ptype, sigma, epsilon\n",
    )

    for atom_idx, atom_type in typemap.items():
        atom = openff_sys.topology.atom(atom_idx)
        parameters = _get_buck_parameters(openff_sys, atom_idx)
        a = parameters["A"].m_as(kj_mol)
        b = parameters["B"].m_as(1 / unit.nanometer)
        c = parameters["C"].m_as(kj_mol * unit.nanometer**6)

        top_file.write(
            "{:<11s} {:6d} {:.16g} {:.16g} {:5s} {:.16g} {:.16g} {:.16g}".format(
                atom_type,  # atom type
                # "XX",  # atom "bonding type", i.e. bond class
                atom.atomic_number,
                atom.mass.m,
                0.0,  # charge, overriden later in [ atoms ]
                "A",  # ptype
                a,
                b,
                c,
            ),
        )
        top_file.write("\n")


def _write_moleculetype(top_file: IO, molecule_name: str):
    """Write the [ moleculetype ] section."""
    top_file.write("[ moleculetype ]\n")
    top_file.write("; Name\tnrexcl\n")
    top_file.write(f"{molecule_name}\t3\n\n")


def _write_atoms(
    top_file: IO,
    openff_sys: "Interchange",
    molecule: "Molecule",
    typemap: Dict,
    virtual_site_map: Dict,
    _cached_parameters=None,
):
    """Write the [ atoms ] and [ pairs ] sections for a molecule."""
    top_file.write("[ atoms ]\n")
    top_file.write(";num, type, resnum, resname, atomname, cgnr, q, m\n")

    for atom in molecule.atoms:
        molecule_index = molecule.atom_index(atom)
        topology_index = openff_sys.topology.atom_index(atom)
        mass = atom.mass.m
        charge = (
            openff_sys["Electrostatics"]
            .charges_with_virtual_sites[TopologyKey(atom_indices=(topology_index,))]
            .m_as(
                unit.elementary_charge,
            )
        )
        atom_type = typemap[topology_index]
        atom_name = atom.name if atom.name else atom.symbol

        try:
            res_idx = atom.metadata["residue_number"]
            res_name = atom.metadata["residue_name"]
        except KeyError:
            res_idx = 0
            res_name = "UNK"

        # TODO: Figure out why charge increments were applied as an array
        # to the anchor atom involved in a BondChargeVirtualSite?
        if type(charge) == np.ndarray:
            charge = charge[0]

        top_file.write(
            "{:6d} {:18s} {:6d} {:8s} {:8s} {:6d} "
            "{:18.8f} {:18.8f}\n".format(
                molecule_index + 1,
                atom_type,
                int(res_idx),
                res_name,
                atom_name,
                molecule_index + 1,
                charge,
                mass,
            ),
        )

    index = molecule.n_atoms + 1

    for virtual_site_key in virtual_site_map:
        if not _this_key_is_in_molecule(
            virtual_site_key,
            openff_sys.topology,
            molecule,
        ):
            continue

        atom_idx = index
        atom_type = "VS"
        res_idx = 1
        res_name = "1"
        charge
        charge_handler = openff_sys["Electrostatics"]
        charge = charge_handler.charges_with_virtual_sites[virtual_site_key].m_as(
            unit.e,
        )
        mass = 0.0

        top_file.write(
            "{:6d} {:18s} {:6d} {:8s} {:8s} {:6d} "
            "{:18.8f} {:18.8f}\n".format(
                atom_idx,
                atom_type,
                res_idx,
                res_name,
                atom_type,
                atom_idx,
                charge,
                mass,
            ),
        )

        index += 1

    top_file.write("\n")

    top_file.write("[ pairs ]\n")
    top_file.write("; ai\taj\tfunct\n")

    try:
        mixing_rule = openff_sys["vdW"].mixing_rule.lower()
        scale_lj = openff_sys["vdW"].scale_14
    except LookupError:
        mixing_rule = openff_sys["Buckingham-6"].mixing_rule.lower()  # type: ignore
        scale_lj = openff_sys["Buckingham-6"].scale_14  # type: ignore

    # Use a set to de-duplicate
    pairs: Set[Tuple] = {*_get_14_pairs(molecule)}

    if "vdW" in openff_sys.handlers:
        if _cached_parameters is None:
            lj_parameters = openff_sys["vdW"].get_system_parameters()
        else:
            lj_parameters = _cached_parameters
    elif "Buckingham-6" in openff_sys.handlers:
        warnings.warn("Not writing a [ pairs ] section with Buckingham interactions.")
        top_file.write("\n")
        return

    # TODO: Sort pairs by atom indices ascending
    for pair in pairs:
        molecule_indices = sorted(molecule.atom_index(atom) for atom in pair)
        topology_indices = sorted(openff_sys.topology.atom_index(atom) for atom in pair)
        sigma1, epsilon1 = lj_parameters[topology_indices[0]]
        sigma2, epsilon2 = lj_parameters[topology_indices[1]]
        epsilon_mix = (epsilon1 * epsilon2) ** 0.5
        if mixing_rule == "lorentz-berthelot":
            sigma_mix = (sigma1 + sigma2) * 0.5
        elif mixing_rule == "geometric":
            sigma_mix = (sigma1 * sigma2) ** 0.5
        top_file.write(
            "{:7d} {:7d} {:6d} {:16g} {:16g}\n".format(
                molecule_indices[0] + 1,
                molecule_indices[1] + 1,
                1,
                sigma_mix,
                epsilon_mix * scale_lj,
            ),
        )

    top_file.write("\n")


def _write_virtual_sites(
    top_file: IO,
    openff_sys: "Interchange",
    molecule: "Molecule",
    virtual_site_map: Dict,
):
    if "VirtualSites" not in openff_sys.handlers:
        return

    virtual_site_handler = openff_sys["VirtualSites"]

    if not all(
        k.type in ["BondCharge", "MonovalentLonePair", "DivalentLonePair"]
        for k in virtual_site_handler.slot_map
    ):
        raise NotImplementedError("Only BondCharge virtual sites are implemented")

    started_virtual_sites2 = False
    started_virtual_sites3 = False
    # TODO: Cleaner implementation than filter + sort? Maybe split it up into each type
    # and do them sequentially?

    slot_map: Dict[VirtualSiteKey, PotentialKey] = virtual_site_handler.slot_map

    # TODO: Consolidate this logic with identical code in coordinate writer

    # TODO: Lots of repeated code, like checking to see if a particular virtual site is in _this_
    #       molecule, etc., should consolidate

    used_keys = dict()

    virtual_site_index = molecule.n_atoms + 1

    for virtual_site_key in sorted(
        (k for k in slot_map if type(k) == VirtualSiteKey),
        key=lambda x: x.type,
    ):
        if virtual_site_key.type == "BondCharge":
            if not started_virtual_sites2:
                top_file.write("\n[ virtual_sites2 ]\n; site  ai  aj  funct   a\n")
                started_virtual_sites2 = True

            orientation_atom_indices: Tuple[
                int,
                ...,
            ] = virtual_site_key.orientation_atom_indices

            if len(orientation_atom_indices) != 2:
                raise NotImplementedError

            offset = openff_sys.topology.atom_index(molecule.atom(0)) - 1

            # virtual_site_index = virtual_site_map[virtual_site_key]
            atom1 = orientation_atom_indices[0]
            atom2 = orientation_atom_indices[1]

            func = 2

            distance = (
                virtual_site_handler.potentials[slot_map[virtual_site_key]]
                .parameters["distance"]
                .m_as(unit.nanometer)
            )

            a = distance

            top_file.write(
                f"{virtual_site_index}\t\t{atom1-offset}\t{atom2-offset}\t"
                f"{func}\t{a}\n",
            )

            used_keys.update({virtual_site_index: virtual_site_key})

        if virtual_site_key.type == "MonovalentLonePair":
            if not started_virtual_sites3:
                top_file.write(
                    "\n[ virtual_sites3 ]\n; site  ai  aj  ak funct   a   b\n",
                )
                started_virtual_sites3 = True

            reference_atoms = tuple(sorted(virtual_site_key.orientation_atom_indices))
            if len(reference_atoms) != 3:
                raise NotImplementedError

            offset = openff_sys.topology.atom_index(molecule.atom(0)) - 1

            atom1 = reference_atoms[0]
            atom2 = reference_atoms[1]
            atom3 = reference_atoms[2]

            if not _this_key_is_in_molecule(
                virtual_site_key,
                openff_sys.topology,
                molecule,
            ):
                continue

            func = 3  # "3fad"

            out_of_plane_angle = (
                virtual_site_handler.potentials[slot_map[virtual_site_key]]
                .parameters["outOfPlaneAngle"]
                .m_as(unit.radian)
            )

            if out_of_plane_angle != 0.0:
                raise NotImplementedError(
                    "Unclear how to do MonovalentLonePair virtual sites with GROMACS",
                )

            distance = (
                virtual_site_handler.potentials[slot_map[virtual_site_key]]
                .parameters["distance"]
                .m_as(unit.nanometer)
            )

            in_plane_angle = (
                virtual_site_handler.potentials[slot_map[virtual_site_key]]
                .parameters["inPlaneAngle"]
                .m_as(unit.degree)
            )

            in_plane_angle_transformed = 180 - in_plane_angle

            top_file.write(
                f"{virtual_site_index}\t\t{atom1 -offset}\t{atom2 -offset}\t{atom3 -offset}\t"
                f"{func}\t{in_plane_angle_transformed}\t{distance}\n",
            )

            used_keys.update({virtual_site_index: virtual_site_key})

        if virtual_site_key.type == "DivalentLonePair":
            if not started_virtual_sites3:
                top_file.write(
                    "\n[ virtual_sites3 ]\n; site  ai  aj  ak funct   a   b\n",
                )
                started_virtual_sites3 = True

            # TODO: Cannot sort here. Atom ordering implies "chirality" of virtual sites,
            #  i.e. which side of a 5-site water each lone pair particle should go.
            reference_atoms = tuple(sorted(virtual_site_key.orientation_atom_indices))

            if len(reference_atoms) != 3:
                raise NotImplementedError

            offset = openff_sys.topology.atom_index(molecule.atom(0)) - 1

            # GROMACS indexes molecules at 1, so the offset is "one less" than 0-indexed OpenFF indices
            offset = openff_sys.topology.atom_index(molecule.atom(0)) - 1

            atom1 = reference_atoms[0]
            atom2 = reference_atoms[1]
            atom3 = reference_atoms[2]

            if _this_key_is_in_molecule(
                virtual_site_key,
                openff_sys.topology,
                molecule,
            ):
                pass
            else:
                continue

            func = 1

            bond1_key = TopologyKey(atom_indices=(atom1, atom2))
            bond1_length = (
                openff_sys["Bonds"]
                .potentials[openff_sys["Bonds"].slot_map[bond1_key]]
                .parameters["length"]
                .m_as(unit.nanometer)
            )

            bond2_key = TopologyKey(atom_indices=(atom1, atom3))
            bond2_length = (
                openff_sys["Bonds"]
                .potentials[openff_sys["Bonds"].slot_map[bond2_key]]
                .parameters["length"]
                .m_as(unit.nanometer)
            )

            if bond1_length != bond2_length:
                raise NotImplementedError

            angle_key = TopologyKey(atom_indices=(atom2, atom1, atom3))
            angle = (
                openff_sys["Angles"]
                .potentials[openff_sys["Angles"].slot_map[angle_key]]
                .parameters["angle"]
                .m_as(unit.radian)
            )

            distance = (
                virtual_site_handler.potentials[slot_map[virtual_site_key]]
                .parameters["distance"]
                .m_as(unit.nanometer)
            )

            out_of_plane_angle = (
                virtual_site_handler.potentials[slot_map[virtual_site_key]]
                .parameters["outOfPlaneAngle"]
                .m_as(unit.radian)
            )

            if out_of_plane_angle == 0:
                func = 1

                a = -1.0 * distance / (math.cos(angle / 2.0) * bond1_length) / 2.0

                top_file.write(
                    f"{virtual_site_index}\t\t{atom1 -offset }\t{atom2 -offset}\t{atom3-offset}"
                    f"\t{func}\t{a}\t{a}\n",
                )

                used_keys.update({virtual_site_index: virtual_site_key})

            else:
                func = 4
                a = (-1 * distance * math.cos(out_of_plane_angle)) / (
                    2 * bond1_length * math.cos(angle / 2)
                )
                c = (-1 * distance * math.sin(out_of_plane_angle)) / (
                    bond1_length**2 * math.sin(angle)
                )

                top_file.write(
                    f"{virtual_site_index}\t\t{atom1-offset}\t{atom2-offset}\t{atom3-offset}"
                    f"\t{func}\t{a}\t{a}\t{c}\n",
                )

                used_keys.update({virtual_site_index: virtual_site_key})

    if len(used_keys) > 0:
        top_file.write("\n[ exclusions ]\n")

    for virtual_site_index, virtual_site_key in used_keys.items():
        orientation_atom_indices = virtual_site_key.orientation_atom_indices

        top_file.write(f"{virtual_site_index}\t")
        top_file.write("\t".join([str(i - offset) for i in orientation_atom_indices]))
        top_file.write("\n")

    top_file.write("\n")


def _write_valence(
    top_file: IO,
    openff_sys: "Interchange",
    molecule: "Molecule",
):
    """Write the [ bonds ], [ angles ], and [ dihedrals ] sections."""
    _write_bonds(top_file, openff_sys, molecule)
    _write_angles(top_file, openff_sys, molecule)
    _write_dihedrals(top_file, openff_sys, molecule)


def _write_bonds(top_file: IO, openff_sys: "Interchange", molecule: "Molecule"):
    if "Bonds" not in openff_sys.handlers.keys():
        return

    top_file.write("[ bonds ]\n")
    top_file.write("; ai\taj\tfunc\tr\tk\n")

    bond_handler = openff_sys["Bonds"]

    for bond in molecule.bonds:

        topology_indices = tuple(
            sorted(openff_sys.topology.atom_index(a) for a in bond.atoms),
        )
        molecule_indices = tuple(sorted(molecule.atom_index(a) for a in bond.atoms))
        topology_indices = tuple(
            sorted(openff_sys.topology.atom_index(atom) for atom in bond.atoms),
        )

        found_match = False
        for top_key in bond_handler.slot_map:
            top_key: TopologyKey  # type: ignore[no-redef]
            if top_key.atom_indices == topology_indices:
                pot_key = bond_handler.slot_map[top_key]
                found_match = True
                break
            elif top_key.atom_indices == topology_indices[::-1]:
                pot_key = bond_handler.slot_map[top_key]
                found_match = True
                break
            else:
                found_match = False

        if not found_match:
            print(
                f"Failed to find parameters for bond with topology indices {topology_indices}",
            )
            continue

        params = bond_handler.potentials[pot_key].parameters

        k = params["k"].m
        length = params["length"].m

        top_file.write(
            "{:7d} {:7d} {:4s} {:.16g} {:.16g}\n".format(
                molecule_indices[0] + 1,  # atom i
                molecule_indices[1] + 1,  # atom j
                str(1),  # bond type (functional form)
                length,
                k,
            ),
        )

        del pot_key

    top_file.write("\n\n")


def _write_angles(top_file: IO, openff_sys: "Interchange", molecule: "Molecule"):
    if "Angles" not in openff_sys.handlers.keys():
        return

    top_file.write("[ angles ]\n")
    top_file.write("; ai\taj\tak\tfunc\tr\tk\n")

    angle_handler = openff_sys["Angles"]

    for angle in molecule.angles:
        # TODO: Toolkit makes little guarantees about atom ordering in angles
        #       (only that the index of the first is less than the last)
        #       Easy breakage point
        topology_indices = tuple(openff_sys.topology.atom_index(a) for a in angle)
        molecule_indices = tuple(molecule.atom_index(a) for a in angle)

        for top_key in angle_handler.slot_map:
            if top_key.atom_indices == topology_indices:
                pot_key = angle_handler.slot_map[top_key]

        params = angle_handler.potentials[pot_key].parameters
        k = params["k"].m
        theta = params["angle"].m

        top_file.write(
            "{:7d} {:7d} {:7d} {:4s} {:.16g} {:.16g}\n".format(
                molecule_indices[0] + 1,  # atom i
                molecule_indices[1] + 1,  # atom j
                molecule_indices[2] + 1,  # atom k
                str(1),  # angle type (functional form)
                theta,
                k,
            ),
        )

    top_file.write("\n")


def _write_dihedrals(top_file: IO, openff_sys: "Interchange", molecule: "Molecule"):
    if "ProperTorsions" not in openff_sys.handlers:
        if "RBTorsions" not in openff_sys.handlers:
            if "ImproperTorsions" not in openff_sys.handlers:
                return

    top_file.write("[ dihedrals ]\n")
    top_file.write(";    i      j      k      l   func\n")

    # FIXME: RB Impropers are probably missed here
    rb_torsion_handler: Optional["PotentialHandler"] = openff_sys.handlers.get(
        "RBTorsions",
        None,
    )
    proper_torsion_handler: Optional["PotentialHandler"] = openff_sys.handlers.get(
        "ProperTorsions",
        None,
    )
    improper_torsion_handler: Optional["PotentialHandler"] = openff_sys.handlers.get(
        "ImproperTorsions",
        None,
    )

    # TODO: Ensure number of torsions written matches what is expected
    for proper in molecule.propers:

        topology_indices = tuple(openff_sys.topology.atom_index(a) for a in proper)
        molecule_indices = tuple(molecule.atom_index(a) for a in proper)

        if proper_torsion_handler:

            for top_key in proper_torsion_handler.slot_map:
                if top_key.atom_indices[0] != topology_indices[0]:
                    continue
                if top_key.atom_indices[1] != topology_indices[1]:
                    continue
                if top_key.atom_indices[2] != topology_indices[2]:
                    continue
                if top_key.atom_indices[3] != topology_indices[3]:
                    continue
                if top_key.atom_indices == topology_indices:
                    pot_key = proper_torsion_handler.slot_map[top_key]
                    params = proper_torsion_handler.potentials[pot_key].parameters

                    k = params["k"].m
                    periodicity = int(params["periodicity"])
                    phase = params["phase"].m
                    idivf = int(params["idivf"]) if "idivf" in params else 1
                    top_file.write(
                        "{:7d} {:7d} {:7d} {:7d} {:6d} {:16g} {:16g} {:7d}\n".format(
                            molecule_indices[0] + 1,
                            molecule_indices[1] + 1,
                            molecule_indices[2] + 1,
                            molecule_indices[3] + 1,
                            1,
                            phase,
                            k / idivf,
                            periodicity,
                        ),
                    )
        # This should be `if` if a single quartet can be subject to both proper and RB torsions
        if rb_torsion_handler:
            for top_key in rb_torsion_handler.slot_map:
                if top_key.atom_indices[0] != topology_indices[0]:
                    continue
                if top_key.atom_indices[1] != topology_indices[1]:
                    continue
                if top_key.atom_indices[2] != topology_indices[2]:
                    continue
                if top_key.atom_indices[3] != topology_indices[3]:
                    continue
                if top_key.atom_indices == topology_indices:
                    pot_key = rb_torsion_handler.slot_map[top_key]
                    params = rb_torsion_handler.potentials[pot_key].parameters

                    c0 = params["C0"].m_as(kj_mol)
                    c1 = params["C1"].m_as(kj_mol)
                    c2 = params["C2"].m_as(kj_mol)
                    c3 = params["C3"].m_as(kj_mol)
                    c4 = params["C4"].m_as(kj_mol)
                    c5 = params["C5"].m_as(kj_mol)

                    top_file.write(
                        "{:7d} {:7d} {:7d} {:7d} {:6d} "
                        "{:16g} {:16g} {:16g} {:16g} {:16g} {:16g} \n".format(
                            molecule_indices[0] + 1,
                            molecule_indices[1] + 1,
                            molecule_indices[2] + 1,
                            molecule_indices[3] + 1,
                            3,
                            c0,
                            c1,
                            c2,
                            c3,
                            c4,
                            c5,
                        ),
                    )

    # TODO: Ensure number of torsions written matches what is expected
    if improper_torsion_handler:

        # Molecule/Topology.impropers lists the central atom **second** ...
        for improper in molecule.smirnoff_impropers:

            topology_indices = tuple(
                openff_sys.topology.atom_index(a) for a in improper
            )
            # ... so the tuple must be modified to list the central atom **first**,
            # which is how the improper handler's slot map is built up
            indices_to_match = (
                topology_indices[1],
                topology_indices[0],
                topology_indices[2],
                topology_indices[3],
            )

            molecule_indices = tuple(molecule.atom_index(a) for a in improper)

            # Now, indices_to_match has the central atom listed **first**,
            # but it's still listed second in molecule_indices

            for top_key in improper_torsion_handler.slot_map:
                if top_key.atom_indices[0] != indices_to_match[0]:
                    continue
                if top_key.atom_indices[1] != indices_to_match[1]:
                    continue
                if top_key.atom_indices[2] != indices_to_match[2]:
                    continue
                if top_key.atom_indices[3] != indices_to_match[3]:
                    continue
                if indices_to_match == top_key.atom_indices:
                    key = improper_torsion_handler.slot_map[top_key]
                    params = improper_torsion_handler.potentials[key].parameters

                    k = params["k"].m
                    periodicity = int(params["periodicity"])
                    phase = params["phase"].m
                    idivf = int(params["idivf"])
                    top_file.write(
                        "{:7d} {:7d} {:7d} {:7d} {:6d} {:.16g} {:.16g} {:.16g}\n".format(
                            # central atom is listed first in GROMACS
                            molecule_indices[1] + 1,
                            molecule_indices[0] + 1,
                            molecule_indices[2] + 1,
                            molecule_indices[3] + 1,
                            4,
                            phase,
                            k / idivf,
                            periodicity,
                        ),
                    )

    top_file.write("\n")


def _write_system(
    top_file: IO,
    openff_sys: "Interchange",
    uniqe_molecule_map: Dict[int, List],
):
    """Write the [ system ] section."""
    top_file.write("[ system ]\n")
    top_file.write("; name \n")
    top_file.write("System name\n\n")

    top_file.write("[ molecules ]\n")
    top_file.write("; Compound\tnmols\n")

    for molecule in openff_sys.topology.molecules:

        top_file.write(f"{molecule.name}\t1\n")

    top_file.write("\n")


def _get_lj_parameters(openff_sys: "Interchange", atom_idx: int) -> Dict:
    vdw_hander = openff_sys["vdW"]
    atom_key = TopologyKey(atom_indices=(atom_idx,))
    identifier = vdw_hander.slot_map[atom_key]
    potential = vdw_hander.potentials[identifier]
    parameters = potential.parameters

    return parameters


def _get_buck_parameters(openff_sys: "Interchange", atom_idx: int) -> Dict:
    buck_hander = openff_sys["Buckingham-6"]  # type: ignore
    atom_key = TopologyKey(atom_indices=(atom_idx,))
    identifier = buck_hander.slot_map[atom_key]
    potential = buck_hander.potentials[identifier]
    parameters = potential.parameters

    return parameters


# TODO: Needs to be reworked in a way that makes sane assumptions about the structure
#       of the topology while parsinng the forces and other data. This may require two
#       passes over the file, one to parse the topology and the other to parse the rest.
def from_top(top_file: Union[Path, str], gro_file: Union[Path, str]):
    """Read the contents of a GROMACS Topology (.top) file."""
    raise NotImplementedError("Internal `from_gromacs` parser temporarily unsupported.")
    from openff.interchange import Interchange

    interchange = Interchange()
    interchange.topology = Topology()
    pesudo_molecule = _SimpleMolecule()
    interchange.topology.add_molecule(pesudo_molecule)

    current_directive = None

    def _process_defaults(interchange: Interchange, line: str):
        fields = line.split()
        if len(fields) != 5:
            raise Exception(fields)

        nbfunc, comb_rule, gen_pairs, lj_14, coul_14 = fields

        if nbfunc == "1":
            vdw_handler = BasevdWHandler()
        elif nbfunc == "2":
            raise NotImplementedError(
                "Parsing GROMACS files with the Buckingham-6 potential is not supported",
            )

        if comb_rule == "1":
            vdw_handler.mixing_rule = "geometric"
        elif comb_rule == "2":
            vdw_handler.mixing_rule = "lorentz-berthelot"
        else:
            raise RuntimeError(f"Found bad/unsupported combination rule: '{comb_rule}'")

        # TODO: Process pairs

        electrostatics_handler = BaseElectrostaticsHandler()

        vdw_handler.scale_14 = float(lj_14)
        electrostatics_handler.scale_14 = float(coul_14)

        interchange.add_handler("vdW", vdw_handler)
        interchange.add_handler("Electrostatics", electrostatics_handler)

    def _process_atomtype(interchange: Interchange, line: str):
        fields = line.split()
        if len(fields) != 7:
            raise Exception

        atom_type, atomic_number, mass, charge, ptype, sigma, epsilon = fields

        potential_key = PotentialKey(id=atom_type)
        if potential_key in interchange["vdW"].potentials:
            raise RuntimeError

        potential = Potential(
            parameters={
                "sigma": float(sigma) * unit.nanometer,
                "epsilon": float(epsilon) * unit.kilojoule / unit.mole,
            },
        )

        interchange["vdW"].potentials.update({potential_key: potential})

    def _process_moleculetype(interchange: Interchange, line: str):
        from openff.toolkit.topology.molecule import Molecule

        fields = line.split()
        if len(fields) != 2:
            raise Exception

        molecule_name, nrexcl = fields

        if nrexcl != "3":
            raise Exception

        molecule = Molecule()
        molecule.name = molecule_name

        if interchange.topology is not None:
            raise Exception

        topology = molecule.to_topology()

        interchange.topology = topology

    def _process_atom(interchange: Interchange, line: str):
        fields = line.split()
        if len(fields) != 8:
            raise Exception

        (
            atom_number,
            atom_type,
            residue_number,
            residue_name,
            atom_name,
            cg_number,
            _charge,
            mass,
        ) = fields

        # TODO: Fix topology graph
        interchange.topology.molecules[0].add_atom(
            atomic_number=0,
            metadata={
                "residue_number": residue_number,
                "residue_name": residue_name,
            },
        )

        topology_key = TopologyKey(atom_indices=(int(atom_number) - 1,))
        potential_key = PotentialKey(id=atom_type)

        if potential_key not in interchange["vdW"].potentials:
            raise RuntimeError(
                f"Found atom type {atom_type} in an atoms directive but "
                "either did not find or failed to process an atom type of the same name "
                "in the atomtypes directive.",
            )

        charge: "Quantity" = unit.Quantity(float(_charge), units=unit.elementary_charge)

        interchange["vdW"].slot_map.update({topology_key: potential_key})
        # The vdw .potentials was constructed while parsing [ atomtypes ]
        interchange["Electrostatics"].slot_map.update({topology_key: potential_key})
        interchange["Electrostatics"].potentials.update(
            {potential_key: Potential(parameters={"charge": charge})},
        )

    def _process_pair(interchange: Interchange, line: str):
        pass

    def _process_bond(interchange: Interchange, line: str):
        fields = line.split()
        if len(fields) != 5:
            raise Exception

        if "Bonds" not in interchange.handlers:
            bond_handler = BaseBondHandler()
            interchange.add_handler("Bonds", bond_handler)

        atom1, atom2, func, length, k = fields

        # Assumes 1-molecule topology
        interchange.topology.molecules[0].add_bond(
            atom1=int(atom1) - 1,
            atom2=int(atom2) - 1,
        )

        topology_key = TopologyKey(atom_indices=(int(atom1) - 1, int(atom2) - 1))
        potential_key = PotentialKey(
            id="-".join(str(i) for i in topology_key.atom_indices),
        )

        # TODO: De-depulicate identical bond parameters into "types"
        potential = Potential(
            parameters={
                "length": float(length) * unit.nanometer,
                "k": float(k) * unit.kilojoule / unit.mole / unit.nanometer**2,
            },
        )

        interchange["Bonds"].slot_map.update({topology_key: potential_key})
        interchange["Bonds"].potentials.update({potential_key: potential})

    def _process_angle(interchange: Interchange, line: str):
        fields = line.split()
        if len(fields) != 6:
            raise Exception

        if "Angles" not in interchange.handlers:
            angle_handler = BaseAngleHandler()
            interchange.add_handler("Angles", angle_handler)

        atom1, atom2, atom3, func, theta, k = fields

        topology_key = TopologyKey(
            atom_indices=(int(i) - 1 for i in [atom1, atom2, atom3]),
        )
        potential_key = PotentialKey(
            id="-".join(str(i) for i in topology_key.atom_indices),
        )

        # TODO: De-depulicate identical angle parameters into "types"
        potential = Potential(
            parameters={
                "angle": float(theta) * unit.degree,
                "k": float(k) * unit.kilojoule / unit.mole / unit.radian**2,
            },
        )

        interchange["Angles"].slot_map.update({topology_key: potential_key})
        interchange["Angles"].potentials.update({potential_key: potential})

    def _process_dihedral(interchange: Interchange, line: str):
        fields = line.split()
        if len(fields) != 8:
            raise Exception

        if "ProperTorsions" not in interchange.handlers:
            proper_handler = BaseProperTorsionHandler()
            interchange.add_handler("ProperTorsions", proper_handler)

        if "ImproperTorsions" not in interchange.handlers:
            improper_handler = BaseImproperTorsionHandler()
            interchange.add_handler("ImproperTorsions", improper_handler)

        atom1, atom2, atom3, atom4, func, phase, k, periodicity = fields

        topology_key = TopologyKey(
            atom_indices=(int(i) - 1 for i in [atom1, atom2, atom3, atom4]),
            mult=0,
        )

        def ensure_unique_key(
            handler: Union[BaseProperTorsionHandler, BaseImproperTorsionHandler],
            key: TopologyKey,
        ):
            if key in handler.slot_map:
                key.mult += 1
                ensure_unique_key(handler, key)

        potential_key = PotentialKey(
            id="-".join(str(i) for i in topology_key.atom_indices),
        )

        if func == "1":
            ensure_unique_key(interchange["ProperTorsions"], topology_key)
            potential_key.mult = topology_key.mult

            potential = Potential(
                parameters={
                    "phase": float(phase) * unit.degree,
                    "k": float(k) * unit.kilojoule / unit.mole,
                    "periodicity": int(periodicity) * unit.dimensionless,
                    "idivf": 1 * unit.dimensionless,
                },
            )

            interchange["ProperTorsions"].slot_map.update({topology_key: potential_key})
            interchange["ProperTorsions"].potentials.update({potential_key: potential})

        elif func == "4":
            ensure_unique_key(interchange["ImproperTorsions"], topology_key)
            potential_key.mult = topology_key.mult

            potential = Potential(
                parameters={
                    "phase": float(phase) * unit.degree,
                    "k": float(k) * unit.kilojoule / unit.mole,
                    "periodicity": int(periodicity) * unit.dimensionless,
                    "idivf": 1 * unit.dimensionless,
                },
            )

            interchange["ImproperTorsions"].slot_map.update(
                {topology_key: potential_key},
            )
            interchange["ImproperTorsions"].potentials.update(
                {potential_key: potential},
            )

    def _process_molecule(interchange: Interchange, line: str):
        fields = line.split()
        if len(fields) != 2:
            raise Exception

        molecule_name, n_molecules = fields

        if n_molecules != "1":
            raise NotImplementedError(
                "Only single-molecule topologies are currently supported",
            )

    def _process_system(interchange: Interchange, line: str):
        interchange.name = line

    supported_directives: Dict[str, Callable] = {
        "defaults": _process_defaults,
        "atomtypes": _process_atomtype,
        "moleculetype": _process_moleculetype,
        "atoms": _process_atom,
        "pairs": _process_pair,
        "bonds": _process_bond,
        "angles": _process_angle,
        "dihedrals": _process_dihedral,
        "molecules": _process_molecule,
        "system": _process_system,
    }

    with open(top_file) as opened_top:
        for line in opened_top:
            line = line.strip()

            if ";" in line:
                line = line[: line.index(";")].strip()
            if len(line) == 0:
                continue

            if line.startswith("#"):
                raise NotImplementedError(
                    "Parsing GROMACS files with preprocessor commands "
                    "is not yet supported. Found a line with contents "
                    f"{line}",
                )

            elif line.startswith("["):
                current_directive = line[1:-1].strip()
                continue

            if current_directive in supported_directives:
                supported_directives[current_directive](interchange, line)

            else:
                raise RuntimeError(
                    "Found bad top file or unsupported directive. "
                    f"Current directive is: {current_directive}\n"
                    f"Current line is: '{line}'",
                )

    return interchange


def _this_key_is_in_molecule(
    virtual_site_key: VirtualSiteKey,
    topology: Topology,
    molecule: Molecule,
    shortcut=True,
) -> bool:
    """
    Assert that all orientation atoms in this key are in this molecule.

    The `shortcut` code path assumes that if the parent atom of a virtual site is in a molecule, all of
    the orientation atoms are as well.
    """
    if shortcut:
        parent_atom = topology.atom(virtual_site_key.orientation_atom_indices[0])

        return parent_atom.molecule is molecule

    else:
        topology_atom_indices = [topology.atom_index(atom) for atom in molecule.atoms]

        return all(
            orientation_atom_index in topology_atom_indices
            for orientation_atom_index in virtual_site_key.orientation_atom_indices
        )


def _get_residue_info_from_atom(atom) -> Tuple[int, str]:

    try:
        # TODO: Unclear if OpenFF will make residues start at 1 or 0
        residue_idx = int(atom.metadata["residue_number"]) % 100000
        # TODO: After topology refactor, ensure this matches residue names
        # in the topology file (unsure if this is necessary?)
        residue_name = atom.metadata["residue_name"][:5]
    except KeyError:
        residue_idx = 0
        residue_name = "UNK"

    return residue_idx, residue_name
